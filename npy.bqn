âŸ¨SaveNpy,LoadNpyâŸ©â‡

lfâ†@+10
magicStringâ†(@+147)âˆ¾"NUMPY"  # "\x93NUMPY"

To_i16leâ†{@+256(|âˆ¾âŒŠâˆ˜Ã·Ëœ)ğ•©}
# To_i16leâ†âŸ¨16,8â€¿'c'âŸ©â€¢bit._castâˆ˜â‰  # assumes the platform is little-endian
FloatToBytesâ†âŸ¨64,8â€¿'c'âŸ©â€¢bit._cast

FormatShapeâ†{'('âˆ¾(1â†“âˆ¾â¥Š','âˆ¾Ë˜â€¢FmtÂ¨â‰¢ğ•©)âˆ¾')'}

BuildHeaderâ†{ğ•Šğ•©:
  versionâ†1â€¿0
  # Hypothesis: BQN arrays are C-contiguous
  headerDataâ†"{'descr': '<f8', 'fortran_order': False, 'shape': "âˆ¾(FormatShape ğ•©)âˆ¾", }"
  paddingâ†' 'â†‘Ëœ64-64|(â‰ magicString)+2+2+(â‰ headerData)+1
  ! 0=64|(â‰ magicString)+2+2+(â‰ padding)+(â‰ headerData)+1
  headerDataPaddedâ†headerDataâˆ¾paddingâˆ¾lf
  magicStringâˆ¾(@+version)âˆ¾(To_i16le â‰ headerDataPadded)âˆ¾headerDataPadded
}

EncodeNpyâ†BuildHeaderâˆ¾FloatToBytesâˆ˜â¥Š

SaveNpyâ†â€¢file.BytesâŸœEncodeNpy

ParseHeaderâ†{ğ•Šğ•©:
  "Not a valid NPY file"! magicStringâ‰¡(â‰ magicString)â†‘ğ•©
  versionâ†@-Ëœ(0â€¿1+â‰ magicString)âŠğ•©
  headerlenâ†+Â´1â€¿256Ã—@-Ëœ(2â€¿3+â‰ magicString)âŠğ•©
  headerâ†(Â¬âˆŠâŸœ(' 'âˆ¾lf))âŠ¸/headerlenâ†‘(4+â‰ magicString)â†“ğ•©
  shapestrâ†(âŠâŸœ')'â†‘âŠ¢) (1âŠ¸+âˆ˜âŠâŸœ'('â†“âŠ¢) (("shape"â·header)âŠ1)â†“header
  shapeâ†â€¢BQNÂ¨','((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)shapestr
  âŸ¨version,shape,headerlen+2+2+â‰ magicStringâŸ©
}

LoadNpyâ†{ğ•Šğ•©:
  bytesâ†â€¢file.Bytes ğ•©
  versionâ€¿shapeâ€¿datastartâ†ParseHeader bytes
  shapeâ¥ŠâŸ¨8â€¿'c',64â€¿'f'âŸ©â€¢bit._cast datastartâ†“bytes
}
